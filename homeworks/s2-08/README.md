# Постановка задачи

## Цель задания

Задание предназначено для закрепления знаний и формирования умений написания DSL в Tagless Final Encoding и использования DSL

## Контекст

Возвращаемся к задаче из прошлого домашнего задания, где аналогичную задачу надо было решить в стиле Initial Encoding.

## Постановка задачи

### 1. Производственный конвейер ProductionPipeline

Нарабатываем опыт написания интерпретаторов.

В файле `ProductionPipeline.scala` уже есть trait, описывающий возможности нашего конвейера

Так же в объекте-компаньоне описан класс-реализация конвейера.

От вас требуется реализовать методы этого класса.

В прошлый раз построение эффекта вычисления происходило в интерпретаторе. Теперь интерпретатора нет, теперь каждый метод конвейера преобразует конвейер (строит новый, иммутабельная структура)

Функция запуска конвейера `run` запускает на исполнение полностью готовый конвейер. Этот метод уже написан:

```scala
override def run: IO[ProductionFailure, Unit] =
	pipeline.catchAll:
		case e: PipelineError =>
			ZIO.die(new Exception(e.toString()))
		case f: ProductionFailure =>
			ZIO.fail(f)
```

Каждый раз, когда случается поломка, необходимо:
  - отправить событие `BeverageTechnicalError(factoryName)`
  - проверить первышение Repair Treshold
    - если превышен, то завершить работу конвейера с ошибкой `ProductionFailure.ReparingTreshold(factoryName)`
    - если не превышен, то:
      - отправить событие `BeverageProductionRepair(factoryName, repairingTimeMs)`
      - подождать repairingTimeMs миллисекунд
      - отправить событие `BeverageProductionRepaired(factoryName)`
      - продолжить работу

Каждый раз, когда случается брак надо:
 - отправить событие `BeverageProductionNeglect(factoryName)`
 - запустить производство этой бутылки заново (обратите внимание на то, что здесь вам, скорее всего, понадобится рекурсивная функция)

У типа ProductionPipeline есть два тайп-параметра `BrokenningHandled` и `NeglectionHandled` - это фантомные типы. 
Они существуют для того, что бы вы при построении шаблона вычисления (верхнеуровневая логика), указав что конвейер может сломаться с какой-то вероятностью, не забыли навесить обработку поломок, где должны быть счётчики и проверки. аналогично, если на конвейере может произойти брак, то нужна обработка этого события

Класс Impl реализуюий конвейер так же сопровождается классом ProductionPipelinePartiallyApplied, который позволяет хранить параметры инициализации, которые понадобятся не сразу. Такой подход аналогичен partially applied function

### 2. Фабрика напитков ProductionFactory

Нарабатываем опыт написания различных реализаций DSL

ProductionPipeline из первого задания содержал всего одну реализацию, которая умела множеством методов модифицировать выисление и запускать его.

В файле `ProductionFactory.scala` применён другой подход.

Вам надо написать несколько реализаций, которые:

- Initial - пустая, не настроенная, фабрика, которая может быть настроена. Ее поведение должно соответствовать схеме:
	- Вызов configure создает и возвращает ZIO эффект с настроенной, сконфигурированной фабрикой
	- Все остальные вызовы завершаются ZIO эффектом с ошибкой ProductionFactoryInitError.NotConfigured в E-канале
- Configured - сконфигурированная фабрика без заказа. Ее поведение должно соответствовать схеме:
	- Вызов configure позволяет переконфигурировать фабрику
	- Вызов order строит готовую к обработке заказа фабрику
	- Вызов produce завершается ZIO эффектом с ошибкой ProductionFactoryInitError.NotOrdered в E-канале
- Ordered - Фабрика, готовая к обработке заказа. Ее поведение должно соответствовать схеме:
	- Вызов configure позволяет переконфигурировать фабрику
	- Вызов order позволяет сменить заказ фабрики
	- Вызов produce завершается результатом работы конвейера (этот метод написан в демонстрационных целях)

В этом задании от вас не требуется конфигурировать и запускать на исполнение отдельные конвейеры. Этот метод для вас уже написан в демонстрационных целях.

Сравните два подхода (один класс реализации ProductionPipeline и три класса ProductionFactory). Обратите внимание на то, что оба решают одну задачу (реализация интерфейса), но разными способами.

### 3. Производственная площадка ProductionDomain

Отрабатываем написание высокоуровневой логики используя DSL

В файле `ProductionFactory.scala` описан запуск нашей программы, конфигурация тестовой фабрики.

Вам необходимо построить pipeline - сборку фабрики и отправку заказа ей на исполнение.

Обратите внимение на то, что все методы `ProductionFactory` возвращают `ZIO`. Удобнее всего для комбинирования будет использовать `for-comprehansion`
