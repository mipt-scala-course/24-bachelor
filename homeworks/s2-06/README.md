# Постановка задачи

## Цель задания

Задание предназначено для закрепления знаний об обработке ошибок в функциональном стиле и тайплкассах ApplicativeError и MonadError

## Контекст

У нас есть база данных, хранящая в себе данные о картах нашего банка. Для работы с этой базой существует низкоуровневый класс CardServiceDao.
Ваша задача - сделать функциональную обёртку над этим классом, обрабатывающую передачу конфига и опциональность ответа при помощи тайпклассов Ask и MonadError, а также повторение обращений к базе при помощи Retry

## Постановка задачи

Реализуйте трейт [Retry](./src/main/scala/ru/mipt/fp/util/Retry.scala):

Метод `retry` проверяет полученное вычисление на предмет наличия ошибки и её соответствия предикату. Если проверка неуспешна, повторяет вычисление, пока не будет достигнут лимит попыток
Для его реализации используйте тайпклассы Timer и Random:

```scala
trait Timer[F[_]]:
  def sleep(ms: Long): F[Unit]

trait Random[F[_]]:
  ...
  def betweenLong(begin: Long, end: Long): F[Long]
  ...
```

Timer позволяет создавать задержку вычислений величиной в заданное количество миллисекунд, а Random выдаёт случайные значения (в нашем случае важно получение значения типа Long в заданном промежутке).
Используя эти тайпклассы, реализуйте `retry` так, чтобы повторные вычисления производились с произвольной задержкой.

Реализуйте методы [CardService](./src/main/scala/ru/mipt/fp/service/CardService.scala):

* `getCardByUcid` - получение данных о карте по ucid
* `createCard` - добавление новой карты в базу
* `updateCard` - обновление данных о карте
* `deleteCard` - удаление карты из базы

Все ошибки должны ретраиться с помощью Retry