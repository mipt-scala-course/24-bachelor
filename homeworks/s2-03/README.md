# Постановка задачи

## Цель задания

Задание предназначено для закрепления знаний о функторах и FlatMap и навыков по работе с ними.

## Контекст

Мы делаем сервис, который будет вызываться мобильным приложением банка для работы с банковскими картами.

По требованиям безопасности реальная обработка данных банковских карт должны осуществляться в специальном
защищенном контуре, который недоступен извне, по этой причине наш сервис выполняет роль умного гейтвея 
с минимальным количеством бизнес-логики.

Также по требованиям безопасности важно, чтобы реальные карточные данные не хранились нигде за пределами
защищенного контура, а также не передавались наружу без специального запроса, 
поэтому данные карт нужно маскировать специальным образом для отображения пользователю.

Поскольку пользователей у нас много и запросов тоже планируется много, нам стоит подумать о скорости 
работы нашего сервиса и о том, чтобы не делать лишних запросов к системе обработки карточных данных. 
Поэтому мы будем использовать паттерн кэширующего чтения с неким TTL.

## Постановка задачи

Реализуйте методы [CardService](./src/main/scala/ru/mipt/fp/service/CardService.scala):

* `getClientCards` - получение списка карт клиента с кэшированием
* `getCardById` - получение карты по идентификатору с кэшированием
* `deactivateCard` - запрос деактивации карты по идентификатору с инвалидацией кэша

Принцип маскирования:

* Номер карты из `XXXX-XXXX-XXXX-XXXX` должен быть заменен на `XXXX-****-****-*XXX`
* CVV из `XXX` должен быть заменен на `***`
* Срок действия из `MM/YY` должен быть заменен на `**\**`

Обратите внимание, что:

* в кэше не должны сохраняться данные карт как есть
* при попадании в кэш время жизни записи нужно продлевать (TTL скользящий)

## Подсказки

Для реализации маскирования можно воспользоваться тайпклассом [Masking](./src/main/scala/ru/mipt/fp/masking/Masking.scala).

Дополнительно: реализуйте для данного тайпкласса инстанс функтора или напишите в комментарии к PR, почему это невозможно.